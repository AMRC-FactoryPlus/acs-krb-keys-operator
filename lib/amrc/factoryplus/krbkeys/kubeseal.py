# Factory+ / AMRC Connectivity Stack (ACS) KerberosKey management operator

# Kubeseal interaction

from    base64  import b64decode, b64encode
import  json
import  logging
import  random
import  subprocess
import  time
import  tempfile

import  kubernetes                      as k8s
from    kubernetes.client.exceptions    import ApiException

# Currently we seal each secret into its own SealedSecret. This is not essential but
# makes things much easier.

# These need to match up with the JSON generated by kubeseal...
ss_crd = {
    "group": "bitnami.com",
    "version": "v1alpha1",
    "plural": "sealedsecrets",
}

class Kubeseal:
    def fetch_cert (self, ns, seal_with):
        logging.info(f"Fetching sealing cert from {seal_with}")
        name, key = seal_with.split("/")

        core = k8s.client.CoreV1Api()
        config = core.read_namespaced_config_map(namespace=ns, name=name)
        pem = config.data[key]

        tmp = tempfile.NamedTemporaryFile(mode="w+")
        tmp.write(pem)
        tmp.flush()

        return tmp

    def create_sealed_secret (self, cert, ns, name, key, value):
        logging.info(f"Creating sealed secret {ns}/{name}")

        # json wants string values, not bytes.
        b64 = b64encode(value).decode()
        plain = {
            "apiVersion": "v1",
            "kind": "Secret",
            "metadata": {
                "name": name,
                "namespace": ns,
            },
            "data": {
                key: b64,
            }
        }

        plain_js = json.dumps(plain)

        res = subprocess.run(
            ["kubeseal", "--cert", cert.name],
            input=plain_js, stdout=subprocess.PIPE,
            check=True, text=True)
        sealed = json.loads(res.stdout)

        api = k8s.client.CustomObjectsApi()
        api.create_namespaced_custom_object(**ss_crd, namespace=ns, body=sealed)
        logging.info(f"Created sealed secret {ns}/{name} sealed with {seal_with}")

    def maybe_delete_sealed_secret (self, ns, name):
        logging.info(f"Attempting to delete sealed secret {ns}/{name}")
        api = k8s.client.CustomObjectsApi()
        try:
            api.delete_namespaced_custom_object(**ss_crd, namespace=ns, name=name)
        except ApiException as ex:
            if ex.status != 404:
                raise ex
